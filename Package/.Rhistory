# embedding fonts into our pdf figures
if (!require("extrafont")) install.packages("extrafont"); library(extrafont)
# importing fonts from your OS into R, need to be run only once
# font_import()
# show fonts available
# fonts()  # or fonttable()
# load the fonts into R session
loadfonts()
# you would then embed fonts as follows
#pdf("plot_embedded_fonts.pdf", family="Arial", width=4, height=4.5)
#plot(x[, 1], x[, 2], col = "blue", xlab = "PIratio", ylab = "solvency")
#title("PIratio and solvency - drawn\nfrom bivariate normal distribution")
#dev.off()
#embed_fonts("plot_embedded_fonts.pdf")
# however, rmarkdown does that automatically, how can we instruct it
# to embed fonts?
# 1. we need to change the device to cairo_pdf(), this device can
#    automatically embed fonts into PDF plots, normal pdf() cannot
# 2. we add dev.args family argument in the chunk specs
if (output=="latex") {
opts_chunk$set(dev = 'cairo_pdf',
dev.args=list(family="Arial"))
}
```
```{r, MVN_example_simple_fonts_cont}
# now plot the figure as usual
plot(x[, 1], x[, 2], col = "blue", xlab = "PIratio", ylab = "solvency")
title("PIratio and solvency - drawn\nfrom bivariate normal distribution")
```
If you need to draw a *really* high dimensional data (>1000), drawing them with the help of `mvtnorm` package might be too slow. There are `Rcpp` implementations that are faster (see for an example [here](http://stackoverflow.com/questions/22738355/efficiently-radomly-drawing-from-a-multivariate-normal-distribution))
In the figure above PIratio and solvency were uncorrelated, but this is often not realistic. Let us use `mvtnorm` to draw samples for which covariance terms in the $\Sigma$ matrix are not zero.
```{r, MVN_example_corr}
# making things a bit more complicated, say we want one sample with 0.8
# correlation between solvency and PIratio, and one with -0.1
# create small wrapper functions
sigmaXY <- function(rho, sdX, sdY) {
covTerm <- rho * sdX * sdY
VCmatrix <- matrix(c(sdX^2, covTerm, covTerm, sdY^2),
2, 2, byrow = TRUE)
return(VCmatrix)
}
genBVN <- function(n = 1, seed = NA, muXY=c(0,1), sigmaXY=diag(2)) {
if(!is.na(seed)) set.seed(seed)
rdraws <- rmvnorm(n, mean = muXY, sigma = sigmaXY)
return(rdraws)
}
# correlation is slightly negative
sigmaXY(rho=-0.1, sdX=1, sdY=20)
# highly positive
sigmaXY(rho=0.8, sdX=2, sdY=30)
# creating a function for all of this
loanData <- function(noApproved, noDenied, muApproved, muDenied, sdApproved,
sdDenied, rhoApproved, rhoDenied, seed=1111) {
sigmaApproved <- sigmaXY(rho=rhoApproved, sdX=sdApproved[1], sdY=sdApproved[2])
sigmaDenied <- sigmaXY(rho=rhoDenied, sdX=sdDenied[1], sdY=sdDenied[2])
approved <- genBVN(noApproved, muApproved, sigmaApproved, seed = seed)
denied <- genBVN(noDenied, muDenied, sigmaDenied, seed = seed+1)
loanDf <- as.data.frame(rbind(approved,denied))
deny <- c(rep("Approved", noApproved), rep("Denied", noDenied))
target = c(rep(0, noApproved), rep(1, noDenied))
loanDf <- data.frame(loanDf, deny, target)
colnames(loanDf) <- c("PIratio", "solvency", "deny", "target")
return(loanDf)
}
# generating some data
loanDf <- loanData(noApproved=50, noDenied=50, c(4, 150), c(10, 100),
c(1,20), c(2,30), -0.1, 0.6, 1221)
# illustrating the data, note that with ggplot we need to additionally
# specify font family
ggplot(data = loanDf,
aes(x = solvency, y = PIratio, colour=deny, fill=deny)) +
geom_point() +
xlab("solvency") +
ylab("PIratio") +
theme_bw() +
theme(text=element_text(family="Arial"))
```
We use [ggplot](http://ggplot2.org/) package from now on for producing figures - one of amazing set of R packages developed by [Hadley Wickham](http://had.co.nz/), today a chief scientist at RStudio. (some other really useful packages he is developing are [dplyr](https://github.com/hadley/dplyr), [reshape](https://github.com/hadley/reshape), [httr](https://github.com/hadley/httr), [assertthat](https://github.com/hadley/assertthat)).
## Econometric perspective - Linear probability model
Recall the linear regression model:
$$ y(\mathbf{x}) = \mathbf{w}^T \mathbf{x} + w_0. $$
Using Ordinary Least Squares in a problem where variable we are trying to predict takes only two values, 0 and 1, is called **Linear probability model** (LPM). Let us apply it first to our newly created dataset and later on we will worry about the consequences.
```{r, LPM}
# illustrating the dependence of deny on PIratio variable
ggplot(data = loanDf,
aes(x = PIratio, y = target)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous("PIratio", limit = c(1, 16),
breaks = seq(1, 16, 1), expand = c(0, 0)) +
scale_y_continuous("deny", limit = c(-0.4, 1.8),
breaks = seq(-0.4, 1.8, 0.2),
expand = c(0, 0)) +
geom_hline(yintercept = 0, size = 0.3, linetype = 2) +
annotate("text", x = 13, y = 0.1, label = "Approved", family = "Arial") +
geom_hline(yintercept = 1, size = 0.3, linetype = 2) +
annotate("text", x = 3, y = 1.1, label = "Denied", family = "Arial") +
theme_bw() +
theme(text = element_text(family = "Arial"))
# running the linear regression on our dataset,
# but only on PIratio variable and intercept
datafit <- lm(target ~ PIratio + 1, data = loanDf)
summary(datafit)
```
First question that you might ask is what does it mean to fit a line to a binary variable? How is this different than a regression with a continuous regressand?
Let us look at the figure. The scatterplot looks different than usual regression scatterplots due to our binary variable. Still, the figure seems to show there is a positive relationship between *PIratio* of a client and a loan being *denied*: very few clients with payment-to-income ratio below 6 are denied the loan, while above it most are denied. The line depicts the predicted value of *deny* as a function of PIratio. For example, when PIratio=5, the predicted value of deny is 0.2. What does that value mean?
Recall that regression is expectation, namely $E(Y|X_1,...,X_k)$, and when expressed in terms of outcomes and probabilities we get the following expression
$$E(Y|X_1,...,X_k)=0 \times P(Y=0|X_1,...,X_k) + 1 \times P(Y=1|X_1,...,X_k)$$
Hence, for a binary variable $E(Y|X_1,...,X_k) = P(Y=1|X_1,...,X_k)$, the predicted value from regression is the probability that Y=1, given X. Following this we can interpret the value of 0.2 as follows - when PI ratio is 5, the estimated probability of being denied a loan is about 20\%, as computed with the help of coefficients: $P(Y="Denied"|PI ratio)=-0.41 + 5 \times 0.129$.
How do we interpret coefficients from the regression? In a similar manner, unit change in PI ratio is associated with a change of 0.12 in probability that $Y=1$, i.e. that the loan is denied.
One of the advantages of applying OLS in this situation is that we are working with familiar framework where coefficients are easy to interpret. However, there are shortcomings. Even though in this course we will mostly be concerned with predictions, if you are interested in causal estimates you should be careful with standard errors with LPM. With binary dependent variable errors are always [heteroscedastic](https://en.wikipedia.org/wiki/Heteroscedasticity). Standard errors computed above assume homoscedasticity by default and are incorrect, and so are p-values computed based on them. $R^2$ statistic is uninterpretable in this scenario - all data cannot possibly correspond to the predicted line. Finally, note that there are predicted values larger than 1 and smaller than 0 - these obviously cannot be probabilities! LPM can only provide you with an approximation of probabilities, predicted values have to be transformed in a nonlinear fashion to conform to real probabilities, and this the role of probit/logit transformation. In practice, differences between LPM and logit/probit regression might not be that big, especially if there is very few extreme values of the regressors.
## Machine learning perspective - Discriminant functions
We distinguish between three type of linear models for classification:
1. Discriminant Functions
2. Probabilistic Discriminative Models
3. Probabilistic Generative Models
Check section 1.5.4 of Bishop for more details about probabilistic vs. deterministic classification.
Strictly speaking *discriminant function* is the same as LPM, but in machine learning they think about it in a somewhat different manner - they focus much more on decision boundaries. This is useful way to think about categorization and we will use discriminant functions to introduce them.
We convert fitted values $\hat{y}(\mathbf{x})$ to fitted classes variable $\hat{C}$ by the following rule: "Approved" if $\hat{y}(\mathbf{x})<0.5$, "Denied" if $\hat{y}(\mathbf{x})>0.5$.
Why 0.5? It is a simple rationale - as soon as predicted probability for one class is greater than 0.5 we should always choose that class. This holds when costs of correct and incorrect classifications are the same (that we have been assuming here implicitly). You will learn more about this in Machine learning course in due time.
```{r, discFnc}
# simply running the linear regression on our animals dataset
datafit <- lm(target ~ solvency + PIratio + 1, data=loanDf)
summary(datafit)
# grabbing the coefficients
weights <- coef(datafit)[c("solvency", "PIratio")]
bias <- coef(datafit)[1]
# assigning labels
head(predict(datafit))
sum(predict(datafit)>0.5)
# Computing the boundary: since it is a 2-dimensional example the boundary
# is a line.
intercept <- (-bias + 0.5)/weights["PIratio"]
slope <- -(weights["solvency"]/weights["PIratio"])
slope
weights
bias
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
w1
w1 <- solve(t(X)%*%X) %*% t(X) %*% Y
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
slope1 <- ((w1[2,2]-w1[2,1])/(w1[3,1]-w1[3,2]))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(intercept = int1, slope = slope1)
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw()
+ geom_line(intercept = int1, slope = slope1)
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(intercept = int1, slope = slope1)
plot(1,2)
abline(int1,slope1)
int1
slope1
curve(int+slope1*x)
curve(int1+slope1*x)
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_abline(intercept = int1, slope = slope1)
intercept
slope
w1
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
int2 <- ((w1[1,2]-w1[1,3])/ (w1[3,3]-w1[3,2]))
int3 <- ((w1[1,1]-w1[1,3])/ (w1[3,3]-w1[3,1]))
slope1 <- ((w1[2,2]-w1[2,1])/(w1[3,1]-w1[3,2]))
slope2 <-((w1[2,2]-w1[2,3])/ (w1[3,3]-w1[3,2]))
slope3 <-((w1[2,1]-w1[2,3])/ (w1[3,3]-w1[3,1]))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_abline(intercept = int1, slope = slope1)+
geom_abline(intercept = int2, slope = slope2)+
geom_abline(intercept = int2, slope = slop2)
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_abline(intercept = int1, slope = slope1)+
geom_abline(intercept = int2, slope = slope2)+
geom_abline(intercept = int2, slope = slope3)
slope1
slope2
int2
int1
slope1
x <- seq(min(loanDf["PIratio"]), max(loanDf["PIratio"]),
length.out = noApproved+noDenied+Undecided)
line <- int1 + slope*x
boundaryDf2 <- data.frame(PIratio=x, solvency=line,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2)
boundaryDf2
plot(boundaryDf2$solvency,boundaryDf2$PIratio)
line <- int1 + slope1*x
boundaryDf2 <- data.frame(PIratio=x, solvency=line,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2)
line2 <- int2 + slope2*x
boundaryDf3 <- data.frame(PIratio=x, solvency=line2,
deny=rep("New Boundary", length(x)))
boundaryDf3 <- data.frame(PIratio=x, solvency=line2,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2) +
geom_line(data=boundaryDf3)
head(loanDf)
noApproved <- 50; noDenied <- 50; Undecided <- 50
loanDf <- loanData(noApproved, noDenied, Undecided,
c(7, 150), c(10, 100), c(13, 250),
c(2,20), c(2,30),      c(1, 15),
-0.5, 0.3,0.5)
X <- as.matrix(cbind(ind=rep(1, nrow(loanDf)),
loanDf[,c("PIratio", "solvency")]))
Y <- as.matrix(loanDf[,c('target1','target2','target3')])
w1 <- solve(t(X)%*%X) %*% t(X) %*% Y
loanData <- function(noApproved,  noDenied,  Undecided,
muApproved,  muDenied,  muUndecided,
sdApproved,  sdDenied,  sdUndecided,
rhoApproved, rhoDenied, rhoUndecided,
seed=1111)
{
# Create covariance matrices
sigmaApproved    <- sigmaXY(rho=rhoApproved,  sdX=sdApproved[1],  sdY=sdApproved[2])
sigmaDenied      <- sigmaXY(rho=rhoDenied,    sdX=sdDenied[1],    sdY=sdDenied[2])
sigmaUndecided   <- sigmaXY(rho=rhoUndecided, sdX=sdUndecided[1], sdY=sdUndecided[2])
# Generate random data
approved         <- genBVN(noApproved,  muApproved,  sigmaApproved,  seed = seed)
denied           <- genBVN(noDenied,    muDenied,    sigmaDenied,    seed = seed+1)
undecided        <- genBVN(Undecided, muUndecided, sigmaUndecided, seed = seed+2)
# Create basic dataframe
loanDf           <- as.data.frame(rbind(approved,denied,undecided))
# Add target variables and labels
status           <- c(rep("Approved", noApproved), rep("Denied", noDenied),rep("Undecided", Undecided))
target1          <- c(rep(1, noApproved), rep(0, noDenied),rep(0, Undecided))
target2          <- c(rep(0, noApproved), rep(1, noDenied),rep(0, Undecided))
target3          <- c(rep(0, noApproved), rep(0, noDenied),rep(1, Undecided))
# Create final dataframe and prepare output
loanDf           <- data.frame(loanDf, status, target1,target2,target3)
colnames(loanDf) <- c("PIratio", "solvency", "status", "target1","target2","target3")
# Return dataframe with loan data
return(loanDf)
}
noApproved <- 50; noDenied <- 50; Undecided <- 50
loanDf <- loanData(noApproved, noDenied, Undecided,
c(7, 150), c(10, 100), c(13, 250),
c(2,20), c(2,30),      c(1, 15),
-0.5, 0.3,0.5)
X <- as.matrix(cbind(ind=rep(1, nrow(loanDf)),
loanDf[,c("PIratio", "solvency")]))
Y <- as.matrix(loanDf[,c('target1','target2','target3')])
w1 <- solve(t(X)%*%X) %*% t(X) %*% Y
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
int2 <- ((w1[1,2]-w1[1,3])/ (w1[3,3]-w1[3,2]))
int3 <- ((w1[1,1]-w1[1,3])/ (w1[3,3]-w1[3,1]))
slope1 <- ((w1[2,2]-w1[2,1])/(w1[3,1]-w1[3,2]))
slope2 <-((w1[2,2]-w1[2,3])/ (w1[3,3]-w1[3,2]))
slope3 <-((w1[2,1]-w1[2,3])/ (w1[3,3]-w1[3,1]))
x <- seq(min(loanDf["PIratio"]), max(loanDf["PIratio"]),
length.out = noApproved+noDenied+Undecided)
line  <- int1 + slope1*x
line2 <- int2 + slope2*x
boundaryDf2 <- data.frame(PIratio=x, solvency=line,
deny=rep("New Boundary", length(x)))
boundaryDf3 <- data.frame(PIratio=x, solvency=line2,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2) +
geom_line(data=boundaryDf3)
line3 <- int3 + slope3*x
boundaryDf4 <- data.frame(PIratio=x, solvency=line3,
deny=rep("New Boundary", length(x)))
boundaryDf4 <- data.frame(PIratio=x, solvency=line3,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2) +
geom_line(data=boundaryDf3) +
geom_line(data=boundaryDf4)
w1[1,2]
w1
w1 <- solve(t(X)%*%X) %*% t(X) %*% Y
w1
w1[1,2]
w1[3,1]
w1[3,2]
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2)
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
int2 <- ((w1[1,2]-w1[1,3])/ (w1[3,3]-w1[3,2]))
int3 <- ((w1[1,1]-w1[1,3])/ (w1[3,3]-w1[3,1]))
slope1 <- -((w1[2,2]-w1[2,1])/(w1[3,1]-w1[3,2]))
slope2 <--((w1[2,2]-w1[2,3])/ (w1[3,3]-w1[3,2]))
slope3 <--((w1[2,1]-w1[2,3])/ (w1[3,3]-w1[3,1]))
line  <- int1 + slope1*x
line2 <- int2 + slope2*x
line3 <- int3 + slope3*x
boundaryDf2 <- data.frame(PIratio=x, solvency=line,
deny=rep("New Boundary", length(x)))
boundaryDf3 <- data.frame(PIratio=x, solvency= line2,
deny=rep("New Boundary", length(x)))
boundaryDf4 <- data.frame(PIratio=x, solvency=line3,
deny=rep("New Boundary", length(x)))
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2)
geom_line(data=boundaryDf3) +
geom_line(data=boundaryDf4)
ggplot(data = loanDf,
aes(x = solvency, y = PIratio)) +
geom_point() +
xlab("solvency") +
ylab("PI ratio") +
theme_bw() +
geom_line(data=boundaryDf2) +
geom_line(data=boundaryDf3) +
geom_line(data=boundaryDf4)
int1 <- ((w1[1,2]-w1[1,1]) / (w1[3,1] - w1[3,2]))
int2 <- ((w1[1,2]-w1[1,3])/ (w1[3,3]-w1[3,2]))
int3 <- ((w1[1,1]-w1[1,3])/ (w1[3,3]-w1[3,1]))
slope1 <- ((w1[2,2]-w1[2,1])/(w1[3,1]-w1[3,2]))
slope2 <-((w1[2,2]-w1[2,3])/ (w1[3,3]-w1[3,2]))
slope3 <-((w1[2,1]-w1[2,3])/ (w1[3,3]-w1[3,1]))
m <- matrix(rnorm(1000),ncol=20,nrow=500))
m <- matrix(rnorm(1000),ncol=20,nrow=500)
m
deciles = quantile(m, seq(0, 1, 0.1))
deciles
q 	  <- 1:10*0.1
quant.matrix <- apply(m,2, function(j) quantile(j,q))
head(quant.matrix)
dim(quant.matrix)
N02   <- ncol(m)
N03   <- nrow(m)
Qtransform 	 <- matrix(NA, nrow= nrow(data) , ncol = ncol(data))
colnames(Qtransform) <- names(data)
Qtransform 	 <- matrix(NA, nrow= nrow(m) , ncol = ncol(m))
dim(Qtransform)
TC01 <- data[,1]
TC01 <- m[,1]
dim(TC01)
length(TC01)
TC02 <- quant.matrix[,i]
length(TC02)
TC02 <- quant.matrix[,1]
length(TC02)
TC02
TC02 <- quant.matrix[,1]
Qtransform[,1]  <- as.numeric(cut(TC01, TC02, include.lowest = TRUE)
Qtransform[,1]  <- as.numeric(cut(TC01, TC02, include.lowest = TRUE))
2q 	  <- 1:10*0.1
Qtransform[,1]  <- as.numeric(cut(TC01, TC02, include.lowest = TRUE))
had(Qtransform)
Qtransform
TC01[7]
TC02
cut(TC01, TC02, include.lowest = TRUE)
m <- rnorm(100)
deciles = quantile(m, seq(0, 1, 0.1))
ran_dec = as.numeric cut(ran, deciles, include.lowest = TRUE)
ran_dec = as.numeric cut(m, deciles, include.lowest = TRUE)
ran_dec = as.numeric( cut(m, deciles, include.lowest = TRUE)
)
ran_dec
m <- rnorm(1000)
deciles = quantile(m, seq(0, 1, 0.1))
ran_dec = as.numeric( cut(m, deciles, include.lowest = TRUE)
)
is.na(ran_dec)
sum(is.na(ran_dec))
m <- matrix(rnorm(100),ncol=20,nrow=500)
m
q 	  <- 1:10*0.1
q
quant.matrix <- apply(m,2, function(j) quantile(j,q))
m1 <- quant.matrix[,1]
deciles = quantile(m[,1], seq(0, 1, 0.1))
sum(m1 == deciles)
m1
deciles
q
toQuantile <- function(data){
N02   <- ncol(data)
N03   <- nrow(data)
q 	  <- seq(0, 1, 0.1)
quant.matrix <- apply(data,2, function(j) quantile(j,q))
Qtransform 	 <- matrix(NA, nrow= nrow(data) , ncol = ncol(data))
colnames(Qtransform) <- names(data)
for(i in 1:N02){
TC01 <- data[,i]
TC02 <- quant.matrix[,i]
Qtransform[,i]  <- as.numeric(cut(TC01, TC02, include.lowest = TRUE)
)
}
return(Qtransform)
}
m <- matrix(rnorm(100),ncol=20,nrow=500)
toQuantile(m)
m <- matrix(rnorm(1000),ncol=20,nrow=500)
head(toQuantile(m))
head(m)
toQuantile <- function(data){
N02   <- ncol(data)
N03   <- nrow(data)
q 	  <- seq(0, 1, 0.1)
quant.matrix <<- apply(data,2, function(j) quantile(j,q))
Qtransform 	 <- matrix(NA, nrow= nrow(data) , ncol = ncol(data))
colnames(Qtransform) <- names(data)
for(i in 1:N02){
TC01 <- data[,i]
TC02 <- quant.matrix[,i]
Qtransform[,i]  <- as.numeric(cut(TC01, TC02, include.lowest = TRUE)
)
}
return(Qtransform)
}
m <- matrix(rnorm(1000),ncol=20,nrow=500)
head(toQuantile(m))
toQuantile(m)
head(toQuantile(m))
head(quant.matrix)
seq(0, 1, 0.1)
length(seq(0,10,0.1))
quantile(1:100,0)
data(iris)
library(MASS)
iris.d <- iris[,1:4]  # the data
iris.c <- iris[,5]    # the classes
sc_obj <- stepclass(iris.d, iris.c, "lda", start.vars = "Sepal.Width")
sc_obj
plot(sc_obj)
## or using formulas:
sc_obj <- stepclass(Species ~ ., data = iris, method = "qda",
start.vars = "Sepal.Width", criterion = "AS")  # same as above
sc_obj
## now you can say stuff like
## qda(sc_obj$formula, data = B3)
installed.packages(klaR)
installed.packages("klaR")
library(klaR)
library(devtools)
library(roxygen2)
setwd("/home/felix/GSE/Term 2/Kaggle Competition/Riding-free-on-KAGGLE/Package")
create("hclass")
setwd("/home/felix/GSE/Term 2/Kaggle Competition/Riding-free-on-KAGGLE/Package")
setwd("/home/felix/GSE/Term 2/Kaggle Competition/Riding-free-on-KAGGLE/Package")
create("pravetz")
devtools::document()
setwd("/home/felix/GSE/Term 2/Kaggle Competition/Riding-free-on-KAGGLE/Package")
devtools::document()
devtools::document(pravetz)
devtools::document("pravetz")
devtools::document("pravetz")
devtools::document("pravetz")
devtools::document("pravetz")
